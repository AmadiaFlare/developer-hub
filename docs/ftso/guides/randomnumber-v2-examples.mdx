---
title: "RandomNumberV2 Smart Contract Examples"
tags: [advanced, randomness, solidity]
slug: randomnumberv2-smart-contract-examples
description: Learn how to interact with the Random Number V2 interface using various Solidity smart contract examples.
keywords:
  [solidity, randomness, flare-network, smart-contracts, flare, ethereum]
sidebar_position: 7
---

## Random Number V2 Smart Contract Examples

In this section, you'll find Solidity code examples that demonstrate how to interact with the Random Number V2 interface. These examples cover various scenarios, such as fetching the current random number, retrieving historical random numbers, and ensuring the security of random number generation. Each example explains the function being used and how it can be applied in a real-world contract.

### Overview

The Random Number V2 interface provides decentralized, secure random numbers to smart contracts on the Flare network. This interface is designed for long-term support (LTS), ensuring continuity even as underlying contracts evolve or protocols migrate to new versions.

The examples below demonstrate how to implement key functions in your own Solidity contracts.

### Example 1: Get Random Number

This contract implements a simple lottery system that utilizes a secure random number to select a winner. Participants can enter the lottery, and the winner is drawn using the random number generated by the RandomNumberV2Interface.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9.0;

import {RandomNumberV2Interface} from "@flarenetwork/flare-periphery-contracts/coston2/RandomNumberV2Interface.sol";

/**
 * @title LotteryWithRandomNumber
 * @notice A lottery contract that utilizes a secure random number for determining winners.
 */
contract LotteryWithRandomNumber {
    RandomNumberV2Interface internal randomNumberGenerator;

    address[] public participants;
    uint256 public lotteryId;
    uint256 public lotteryEndTimestamp;

    // Event to log lottery results
    event LotteryDrawn(uint256 indexed lotteryId, address winner, uint256 randomNumber, uint256 timestamp);

    /**
     * @notice Initializes the contract with the address of the random number generator.
     * @param _randomNumberGenerator The address of the RandomNumberV2Interface contract.
     */
    constructor(address _randomNumberGenerator) {
        randomNumberGenerator = RandomNumberV2Interface(_randomNumberGenerator);
    }

    /**
     * @notice Enter the lottery.
     * Participants can enter the lottery before it ends.
     */
    function enterLottery() external {
        require(block.timestamp < lotteryEndTimestamp, "Lottery has ended");
        participants.push(msg.sender);
    }

    /**
     * @notice Start a new lottery round.
     * This resets participants and sets the lottery end time.
     * @param duration The duration of the lottery in seconds.
     */
    function startLottery(uint256 duration) external {
        require(participants.length == 0, "Previous lottery must be concluded first");
        lotteryId++;
        lotteryEndTimestamp = block.timestamp + duration;
    }

    /**
     * @notice Draw the winner of the lottery.
     * Requires the lottery to be over and retrieves a secure random number to select the winner.
     */
    function drawLottery() external {
        require(block.timestamp >= lotteryEndTimestamp, "Lottery is still ongoing");
        require(participants.length > 0, "No participants in the lottery");

        // Get the current random number and its properties
        (uint256 randomNumber, bool isSecureRandom, uint256 randomTimestamp) = randomNumberGenerator.getRandomNumber();

        // Use the random number to select a winner
        uint256 winnerIndex = randomNumber % participants.length;
        address winner = participants[winnerIndex];

        // Emit the lottery result
        emit LotteryDrawn(lotteryId, winner, randomNumber, randomTimestamp);

        // Reset participants for the next lottery round
        delete participants;
    }

    /**
     * @notice Get the current number of participants.
     * @return count The number of participants currently in the lottery.
     */
    function getParticipantCount() external view returns (uint256 count) {
        return participants.length;
    }

    /**
     * @notice Get the current lottery status.
     * @return currentLotteryId The current lottery ID.
     * @return endTimestamp The timestamp when the lottery ends.
     */
    function getLotteryStatus() external view returns (uint256 currentLotteryId, uint256 endTimestamp) {
        return (lotteryId, lotteryEndTimestamp);
    }
}

```

### Example 2: Get Historical Random Number

This contract allows for distributing rewards based on historical random numbers generated during specific voting rounds. It could be beneficial for systems that reward participation or contribution based on randomized outcomes from past events.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.7.6 <0.9.0;

import {RandomNumberV2Interface} from "@flarenetwork/flare-periphery-contracts/coston2/RandomNumberV2Interface.sol";

/**
 * @title RewardDistributor
 * @notice A contract to distribute rewards based on historical random numbers from voting rounds.
 */
contract RewardDistributor {
    RandomNumberV2Interface internal randomNumberGenerator;

    // Mapping from voting round ID to reward amount
    mapping(uint256 => uint256) public rewards;
    // Mapping from user addresses to their accumulated rewards
    mapping(address => uint256) public userRewards;

    // Event to log reward distributions
    event RewardsDistributed(uint256 indexed votingRoundId, uint256 totalReward, uint256 randomNumber);

    /**
     * @notice Initializes the contract with the address of the random number generator.
     * @param _randomNumberGenerator The address of the RandomNumberV2Interface contract.
     */
    constructor(address _randomNumberGenerator) {
        randomNumberGenerator = RandomNumberV2Interface(_randomNumberGenerator);
    }

    /**
     * @notice Set the reward for a specific voting round.
     * This function can only be called by the contract owner or an authorized entity.
     * @param _votingRoundId The voting round ID.
     * @param _reward The total reward amount for this voting round.
     */
    function setReward(uint256 _votingRoundId, uint256 _reward) external {
        // Assume only an authorized entity can set rewards (implementation not shown)
        rewards[_votingRoundId] = _reward;
    }

    /**
     * @notice Distribute rewards based on the historical random number of a specific voting round.
     * @param _votingRoundId The voting round ID.
     */
    function distributeRewards(uint256 _votingRoundId) external {
        // Fetch the historical random number and its properties
        (uint256 randomNumber, bool isSecureRandom, uint256 randomTimestamp) = randomNumberGenerator.getRandomNumberHistorical(_votingRoundId);

        // Ensure rewards are set for this voting round
        uint256 totalReward = rewards[_votingRoundId];
        require(totalReward > 0, "No rewards set for this voting round");

        // Calculate reward distribution based on the random number
        uint256 distributedReward = (randomNumber % totalReward) + 1; // Ensures at least 1 reward is given

        // Log the reward distribution
        emit RewardsDistributed(_votingRoundId, distributedReward, randomNumber);

        // Assuming a simple method to distribute reward (this could be more complex in a real implementation)
        userRewards[msg.sender] += distributedReward; // Reward the caller

        // Reset the reward for that voting round after distribution
        rewards[_votingRoundId] = 0;
    }

    /**
     * @notice Withdraw accumulated rewards.
     */
    function withdrawRewards() external {
        uint256 rewardAmount = userRewards[msg.sender];
        require(rewardAmount > 0, "No rewards to withdraw");

        // Reset the user's rewards to zero before transferring
        userRewards[msg.sender] = 0;

        // Transfer the rewards to the user (using a safe transfer pattern)
        payable(msg.sender).transfer(rewardAmount);
    }

    /**
     * @notice Fallback function to accept incoming ether.
     */
    receive() external payable {}
}
```
