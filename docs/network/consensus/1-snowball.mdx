---
title: Snowball
description: Learn the basics of the consensus protocol running on Flare.
keywords: [consensus]
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import CodeBlock from "@theme/CodeBlock";
import ThemedImage from "@theme/ThemedImage";
import useBaseUrl from "@docusaurus/useBaseUrl";

**Snowflake** and **Snowball** are enhancements to the original Slush protocol, introducing additional global and local parameters to govern when a node may finalize its decision.

- `Beta`: the required number of consecutive successful queries that support the same outcome before a node can finalize.
  In other words, a node is deemed to be finalized once it achieves the same decision in `Beta` consecutive successful rounds.
  This represents a significant improvement over Slush, which lacked any dynamic security mechanism within its fixed termination conditions.

- Confidence counter: Snowball adds to this logic an additional local confidence counter, `confidence`, which effectively further extends the protocol memory.
  This counter tracks the number of consecutive successful polls that have returned the current preference.
  A node will only update its local **preference** if the counter for a new state exceeds that of the current preference.

## Snowball's `Tree` structure

In the Go implementation from the [snow/consensus/snowball](https://github.com/flare-foundation/go-flare/tree/main/avalanchego/snow/consensus/snowball) package, the Snowflake and Snowball protocols share a common interface.
For both protocols, decisions are made on the 32-byte binary form of the proposed blocks.

To effectively deal with more than two choices at a time (i.e. `nnary` logic as opposed to binary or unary setups), Snowball implements a `Tree` structure for all concurrent decisions.
This implementation is specialized to handle multi-branch conflicts elegantly, by modeling them as a hierarchy, and thus optimizing the algorithm be allowing pruning.

More precisely, concurrent blocks at the same height are organised in a tree-like structure based on the first differing bit.
As such, when adding a new block, the tree branches out through a `binaryNode` at the first differing bit, with the counting done from the most significant bit to the least significant bit.
Here, bit indices are defined as:

```
[7 6 5 4 3 2 1 0] [15 14 13 12 11 10 9 8] ... [255 254 253 252 251 250 249 248]
```

An example of how concurrent blocks may be organised within the `Tree` structure is depicted below, where the first differing bit in a byte is also highlighted.

<div style={{ textAlign: "center", margin: "30px 0" }}>
  <ThemedImage
    style={{ width: "50%" }}
    alt="Snowball Tree Implementation"
    sources={{
      light: useBaseUrl("img/consensus/snowball_tree_light.svg"),
      dark: useBaseUrl("img/consensus/snowball_tree_dark.svg"),
    }}
  />
</div>

In the `Tree` implementation, each node in the tree structure holds a `Preference` and a `confidence` counter.
Note that if the counter of a `binaryNode` increases following a successful poll, this propagates further up the tree towards the root node.
`binaryNodes` can finalize only when the confidence counter reaches the globally defined `Beta` value, upon which they are replaced by `unaryNodes`, thus leading to branch trimming.

A key aspect of this implementation is that it avoids running polls for every single bit in the 32-byte representation at each block height.
Next up we will see how Snowman optimizes the consensus algorithm further, by implementing a graph-like structure for blocks at different heights.
